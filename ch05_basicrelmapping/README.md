# many2one or one2many
* 연관관계의 규칙
    - 두 연관관계중 하나를 연관관계의 주인으로 정해야한다.
    - 연관관계의 주인만이 데이터베이스 연관관계와 매핑되고 외래 키를 관리(등록 수정 삭제)할 수 있다.
    - 주인이 아닌 쪽은 읽기만 할 수 있다.
    - 주인은 mappedBy 속성을 사용하지 않는다!!!
    - 주인이 아니면 mappedBy 속성을 사용해서 주인의 속성이름으로 지정해야한다.

* 누가 연관관계의 주인이 되어야하나
    - 자기 테이블에 외래키가 있는 곳으로 해야한다
    - many2one 에서는 Member.class 엔티티가 주인을 맡아야한다.
    - 따라서 Team.class에 멤버연관배열에 mappedBy 어노테이션을 써줘야한다
    - 보통 many쪽이 주인이 된다

# 주의
* 양방향 매핑시 json 화 등을 쓰기위해서 toString() 햇을때 무한루프가 돌수있으니 조심해야함
* member.toString -> getTeam() -> getMember() -> member.toString -> ... 등등



# many2many 
* 다대다
    - 관계형db에서 정규화된 테이블 두개로 다대다를 표현못함
    - 중간에 두개의 외래키를 가지고있는 테이블 하나 더 필요함

* 연결 엔티티 > many2manywmid
    - 중간에 있는 member_product 엔티티에도 데이터가 들어갈수있게끔 엔티티 만들어서 관리해줘야한다 보통,
    - 하다보면 

* 복합 기본키
    - 복합 키는 별도의 식별자 클래스로 만들어야한다
    - Serializable을 구현해야 한다
    - equals와 hashcode 메소드를 구현해야한다
    - 기본 생성자가 있어야한다
    - 식별자 클래스는 public 이어야한다
    - @IdClass를 사용하는 방법 외에 @EmbeddedId를 사용하는 방법도 있다.

* 복합키 쓰는 것은 상당히 어렵다
* 복합키 안쓰고 다대다 관계를 표현하는 방법도 있다.
    - 이거는 코드에 안넣고 여기다가 말로 표현함
    - 단순히 MemberProduct Class에 auto increment 등으로 올라가는 MemberProduct만의 id를 부여해주면된다
    - 그리고 Product와 Member와의 관계를 ManyToOne으로한 조인 부분도 넣으면 된다.
    - 심플하고 강력하다.

* 식별관계 비식별관계
    - 식별관계 = 복합키 쓰는 (두개의 외래키를 가져와서 기본키로 쓰는)
    - 비식별관계 = 자신만의 기본키가 있고 외래키는 외래키로만 사용 단순 (왠만하면 이걸 사용해라)