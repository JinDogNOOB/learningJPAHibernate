# learn hibernate
* n+1 문제 : 연관된 엔티티또 또 불러와서 일을 두번한다. fetch 를 사용하면 미리 가져오는 전략을 사용하기때문에 일을 한번만 한다
## ch01_testing > ./ch01_testing
* 기본적인 hibernate 사용
    - 엔티티매니저팩토리 생성은 비용이 많이 드니 어플리케이션 당 하나
    - 앤티티매니저를 여러 쓰레드에서 공동으로 쓰지말라
    - persistence.xml 작성!!
## ch03 > ./ch01_testing
* 영속성 관리
* em.persist(member)
* 단순히 회원 엔티티를 저장이 아니라 -> 엔티티 매니저를 사용해서 회원 엔티티를 영속성 컨텍스트에 저장
* 영속성 컨텍스트는 엔티티 매니저를 생성할때 하나 만들어지고, 엔티티매니저를 통해서 이것에 접근하거나 관리할 수 있음
* 엔티티 생명주기
    - 비영속(new/transient) : 영속성 컨텍스트와 전혀 관계가 없음
        - new -> persist() -> managed
    - 영속(managed) : 영속성 컨텍스트에 저장된 상태
        - managed -> close(), clear(), detach() -> detached
        - managed -> remove() -> removed
        - DB에 flush 명령
        - find() with JPQL -> managed 
    - 준영속(detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태
        - detached -> merge() -> managed
    - 삭제(removed) : 삭제된 상태
        - removed -> persist() -> managed

* 엔티티 생명주기 설명
    - 비영속
        - 엔티티 객체를 new Member() 식으로 생성한 상태, 순수한 객체 상태, 따라서 영속성컨텍스트나 디비와 관계없음
    - 영속
        - 엔티티 매니저를 통해서 persist() 메소드 통해 영속성 컨텍스트에 저장됐다. 이렇게 영속성 컨텍스트가 관리하는 엔티티를 영속상태라함
        - 엔티티 매니저에 의해 관리되는 상태가 되었다...
        - em.find() 또는 JPQL을 통해 조회한 엔티티도 영속성 컨텍스트에 의해 관리된다
    - 준영속
        - 영속성 컨텍스트가 관리하던 영속 상태의 엔티티를 영속성 컨텍스트가 관리하지 않으면 준영속 상태가 됨
        - em.detach() 를 통해서 준영속 상태로 만들 수 있다. 
        - em.close() 를 호출해서 영속성 컨텍스트를 닫거나 em.clear() 를 호출해서 영속성 컨텍스트를 초기화해도 관리되던 영속상태 엔티티들이 동일하게 준영속상태로 된다
    - 삭제
        - 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제한다
        - em.remove()
* 영속성 컨텍스트 특징
    - 식별자값
        - 영속성 컨텍스트는 엔티티를 식별자값(@Id로 테이블의 기본키와 매핑한 값)으로 구분함
        - 반드시 영속상태는 식별자 값이 있어야함 -> 없으면 exception
    - 영속성 컨텍스트에 있는 엔티티의 저장 시기
        - 보통 트랜잭션을 커밋하는 순간 -> 영속성컨텍스트에 저장된 엔티티를 데이터베이스에 반영
        - 위 같은 상황을 flush 라고 함(쓰기 지연 SQL 저장소 에 모인 쿼리(변경감지:스냅샷 비교 후 확인된 변경사항적용 쿼리 포함)를 db에 보내서 서로 상태 동기화)

## ch04 > ./ch01_testing
* 엔티티 매핑

## ch05 > ./ch05_basicremapping
* 연관관계 매핑 기초
    - 객체의 참조와 테이블의 외래키를 매핑
* 방향
    - 방향
        - 둘 중 한쪽만 참조하는 것을 단방향 관계라고 함
        - 회원 -> 팀 또는 팀 -> 회원
        - 서로 참조하는 경우는 양방향이라고함
    - 다중성
        - N:1, 1:N, 1:1, N:M
        - 만약에 회원과 팀이 관계가 있을때 
        - 여러 회원은 한 팀에 속하므로 회원과 팀은 다대 일 관계임
    - 연관관계의 주인
        - 객체를 양방향 연관관계로 만들면 연관관계의 주인을 정해야 한다

## ch06 > ./ch06_admapping
* 고급 매핑
* 상속관계 매핑
    - 객체의 상속 관계를 테이터베이스에 매핑하는 방법
    - 환경
        - orm(상속) < - > db(슈퍼타입 서브타입) 과 유사 이런식을 할때 사용함
    - DB 테이블 설계 방법
        - 1. 각각의 테이블로 변환 (공통 테이블, 앨범 테이블, 무비 테이블, 책 테이블) 조인전략
        - 2. 통합 테이블로 변환 (하나의 테이블에 컬럼 다 집어넣고 구분컬럼 DTYPE 삽입)
        - 3. 서브타입 테이블로 변환 (서브타입마다 하나의 테이블 생성 (앨범, 무비, 책 테이블))
    - 조인전략 > joinStrategy
        - 장점 : 테이블정규화, 저장공간 효율적
        - 단점 : 조회할 때 조인이 많이 사용되므로 성능 저하우려, 조회쿼리 복잡, 등록할때 insert sql 두번 동작
    - 단일 테이블 전략 > singleTableStrategy
        - 조인전략이랑 클래스설계는 다른게 없음
        - 어노테이션 밸류만 single_table로 바꾸면됨
        - db 컬럼에 null허용 해줘야한다
        - 장점 : 조인이 필요없으므로 조회성능 빠름, 조회쿼리 단순
        - 단점 : 자식 엔티티가 매핑한 컬럼은 모두 null허용해야함, 단일 테이블에 전부 저장하므로 테이블이 커질 수 있음, 상황에 따라서 성능저하 유발
        - 주의 : 구분컬럼 꼭 넣어야한다. 구분컬럼 설정안하면 기본적으로 엔티티 이름 사용함
    - 구현 클래스마다 테이블 전략
        - @Inheritance 의 strategy에 TABLE_PER_CLASS 설정
        - 클래스 구조는 조인전략과 다를 게 없음
        - 장점 : 서브타입 구분해서 처리할때 효과적, not null 제약조건 사용가능
        - 단점 : 여러 자식 테이블을 함께 조회할때 성능 느림(sql union), 통합해서 쿼리하기 어려움 자식들을 하나로
        - 주의 : orm전문가 db설계전문가 둘 다 추천하지 않는 방법임 지양

* @MappedSuperclass
    - 여러 엔티티에서 공통적으로 사용하는 매핑 정보(등록일, 수정일)만 상속받는 방법
    - 부모추상클래스는 실제 db에 매핑되지않는다 entity가 아니다
    - 부모추상클래스는 단순히 자식클래스에 매핑필드 정보만 준다.
    - Member와 Seller 두 엔티티에 id와 name의 공통 필드가 있으면 이것만 빼서 부모추상클래스에 넣는 방법이다. 반복해서 넣기 귀찮을때 사용하는 방법일 수도 있다. 또는 자주 바뀌는 요구사항을 맞추기위해 유지보수 쉽게하기위해
    - 부모의 매핑정보를 재정의하려면 오버라이드하면 된다.

* 복합 키와 식별 관계 매핑
    - 테이터 베이스에서 식별자가 하나 이상일때 매핑하는 방법, DB설계시 식별관계와 비식별관계에 대해 
    - 식별관계와 비식별관계
        - 식별관계 : 부모로부터 기본키를 내려받아서 이를 자식테이블 기본키 + 외래키 두개의 역할로 쓸때 부모와 자식을 식별관계라고함
        - 비식별관계 : 자식의 키가 따로있고 부모로부터 받은 키는 외래키로만 사용, 선택적 비식별관계(외래키 null 가능), 필수적 비식별관계(부모키필수로 받아야한다!)
        - 최근 선호도 : 주로 비식별관계를 쓰고 필요한 곳에만 식별관계 사용
    - 복합키:비식별 관계일때 > deidentifiedRel
        - 그냥 하나의 엔티티에 @Id 두개 넣으면 안됨 매핑오류 발생
        - JPA는 복합키를 지원하기 위해 @IdClass, @EmbeddedId 라는 두가지 방법 지원
        - @IdClass : 관계형 테이터베이스에 가까운 방법
        - @EmbeddedId : 객체지향에 가까운 방법
    - 복합키:식별 관계일때 > identifiedRel

* 조인 테이블
    - 외래키 하나로 연관관계를 맺는 것 대신에 연결 테이블을 두는 방식을 사용할때, 이 연결 테이블을 매핑하는 방법.. 별로 안쓴다고함
* 엔티티 하나에 여러 테이블 매핑
    - 보통 엔티티 하나에 하나의 테이블을 매핑하는데, 여러 테이블을 매핑하는 방법, 별로 안쓴다고함


## ch08
* 프록시 & 연관관계 관리
* 프록시와 즉시로딩, 지연로딩
    - 객체는 객체 그래프로 연관된 객체들을 탐색, 그런데 객체가 데이터베이스에 저장되어 있으므로 연관된 객체를 마음껏 탐색하기는 어려움, JPA 구현체들은 이 문제를 해결하기 위해서 프록시라는 기술을 사용함. 프록시를 사용하면 연관된 객체를 처음부터 데이터베이스에서 조회하는것이 아니라, 실제 사용하는 시점에 데이터베이스에서 조회하는 것임. 하지만 자주사용하는 것이면은 조인을 사용해서 함께 조회하는것이 좋음. JPA는 즉시로딩과 지연로딩이라는 방법으로 두가지를 모두 지원함
    - 프록시
        - Team team = em.getReference(Team.class, "team1"); team.getId(); // 초기화되지않음
        - @Access(AccessType.PROPERTY) 설정인 경우에만 초기화하지않는다.
        - @Access(AccessType.FIELD) 설정인 경우에는 프록시 객체를 초기화한다.
        - 이 프록시를 사용하면 멤버를 생성하고 멤버에 연관관계를 주입할때 유용하게쓸수있다. 데이터베이스 접근 횟수를 줄일수있다.
        - em.getEnmtityManagerFactory().getPersistenceUnitUtil().isLoaded(object) 로 프록시가 초기화 됬는지 확인 가능하다
    - 즉시로딩
        - 멤버조회할때 연관된 팀도 가져옴
        - @ManyToOne(fetch = FetchType.EAGER)
    - 지연로딩
        - 연관된 엔티티를 실제로 사용할때 가져온다
        - @ManyToOne(fetch = FetchType.LAZY)
    - JPA의 기본전략
        - ~ToMany 일때는 지연
        - ~ToOne 일때는 즉시

* 영속성 전이와 고아 객체
    - JPA는 연관된 객체를 함께 저장하거나 함께 삭제할 수 있는 '영속성 전이'와 '고아 객체 제거' 라는 편리한 기능을 제공함
    - CascadeType 옵션
        - ALL : 전부적용
        - PERSIST : 영속 child에 부모넣고 부모 persist하면 자식도 자동으로 저장
        - MERGE : 병합
        - REMOVE : 삭제 부모만 없애도 자식도 다 없어짐
        - REFRESH : refresh
        - DETACH : detach
    - CasCade 옵션은 @OneToMany 안에 설정한다 ex(cascade = CascadeType.PERSIST)
    - 고아 객체 제거 orphanRemoval = true -> 부모엔티티의 자식s 엔티티에서 컬렉션에서 제거하면 삭제된다.

## ch09
* 값 타입
    - 기본값 타입
    - 임베디드 타입(복합 값 타입)
    - 값 타입과 불변 객체
    - 값 타입의 비교
    - 값 타입 컬렉션
* 기본값 타입
    - int, double, 래퍼클래스(Integer), String
* 임베디드 타입(복합 값 타입)
    - @Embeddable 어노테이션붙인 Period 클래스에 Date startDate, endDate; 선언해놓고 실제 Entity 클래스에서 Emgedded Period workPeriod; 식으로 쓰면 응집력있게 쓸수있다. 간단한 구조체 마냥 
* 컬렉션 값 타입 > ./ch09_collectionvalue
    - 값 타입을 하나 이상 저장하려면
    - ex) 좋아하는 음식들, 주소들 을 하나의 멤버에 연관

## ch10 > ./ch10_ooquery
* 객체지향쿼리언어 > simple_jpql
    - EntityManager.find(), a.getB().getC() 와 같은 단순한 검색만으로는 어플리케이션 개발 어려움
    - ORM은 테이블이 아닌 객체를 대상으로 개발하는 방식
    - 따라서 엔티티 객체를 대상으로 검색을 하는 방법이 필요 -> JPQL 등장
* JPQL
    - 테이블이 아닌 객체를 대상으로 검색하는 객체지향쿼리
    - SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지않는다.
* JPA가 공식지원하는 다양한 검색지원방식
    - JPQL(Java Persistence Query Language)
    - Criteria 쿼리(Criteria Query) : JPQL을 편리하게 작성하도록 도와주는 api, 빌더 클래스 모음
    - 네이티브 SQL : JPA에서 jpql대신 직접 SQL을 사용할 수 있다.
    - QueryDSL : Criteria 쿼리처럼 JPQL을 편하게 작성하도록 도와주는 빌더 클래스 모음, 비표준 오픈소스 프레임워크
    - JDBC 직접 사용 : MyBatis 같은 SQL 매퍼 프레임워크 사용 : 필요하면 JDBC를 직접 사용할 수 있다.
* 명심
    - QueryDSL, Criteria 도 JPQL을 편하게 사용하도록 도와주는 빌더클래스일뿐임
    - 중요한거는 JPQL
* 기본 사용
    - JPQL > jpql
        - jpql 키워드(select, 등)은 대소문자 구분 안하지만 엔티티 이름은 대소문자 구분함
        - 별칭은 필수 select m.userName from Member m 처럼 별칭 m같이 꼭 별칭 줘야함  
    - Criteria
        - Criteria 쿼리는 jpql을 자바코드로 작성하도록 도와주는 빌더 클래스api
        - 문법 오류를 컴파일 단계에서 잡을 수 있고 문자 기반의 jpql보다 안전하게 동적쿼리를 짤 수 있다.
        - 대신 코드가 복잡하고장황해서 직관적으로 이해가 힘들다 
    - QueryDSL > querydsl
        - Criteria보다 간결한 오픈소스 프로젝트
        - 공식문서 www.querydsl.com/static/querydsl/x.x.x/reference/ko-KR/html_signle/
    - Native SQL 사용 > nativeSql
        - JPA에서 지원하는 NativeSQL을 사용하면 DB고유의 기능도 사용가능하고 엔티티를 조회했을때 영속성 컨텍스트의 기능을 그대로 사용가능
* 심화
    - 벌크연산
        - 엔티티 다수를 수정할때 하나하나 바꾸면 시간이 너무 오래걸림
        - 여러 건을 한번에 삭제하거나 수정하는 벌크연산 필요 excuteUpdate()
        - int reusltCount = em.createQuery("수정 or 삭제 jpql").setParameter("amount", 10).executeUpdate();
        - db에 직접 요청하는 것이기 때문에 영속성 컨텍스트와 안맞을 수 있다. 
        - em.refresh(Entity) 로 다시 원하는 엔티티를 재조회하거나
        - 벌크연산을 가장먼저 실행하거나
        - 벌크연산 수행후 영속성 컨텍스트를 초기화하는 것이다.
    - 쿼리 후 영속상태
        - Member같은 엔티티를 조회하면 영속컨텍스트에서 관리하지만 단순값이나 member.address 같은것만 조회해오면 관리안한다.
    - em.find() vs JPQL
        - find는 영속컨텍스트에 찾고자하는게 있으면 그것을 준다(1차캐시라고함) 없으면 db조회
        - jpql은 무조건 db먼저 조회하고 조회한 값이 영속컨텍스트에 있는 값이면 버리고 영속컨텍스트에 있던 값 반환
    - jpql과 flush모드
        - em.setFlushMode(FlushModeType.AUTO); //커밋 또는 쿼리 실행시 플러시(기본값)
        - em.setFlushMode(FlushModeType.COMMIT); //커밋시에만 플러시
        - 만약 그 jpql 작업에만 플러쉬모드를 바꿔서쓰고싶다 하면 em.createQuery(~,~).setFlushMode(FlushModeType.?) 하면 된다
        - 성능최적화를 위해서 적절히 사용하자 
## ch11 
* 웹 어플리케이션 제작
* 단계
    - 프로젝트 환경설정
    - 도메인 모델, 테이블 설계
    - 어플리케이션 기능 구현
* 프로젝트 환경설정
    - Maven 설치 후 환경변수 path에 등록
* 스프링 설정 
    - web.xml, root-context, servlet-context => java config
    - 의존성 추가
    - datasource 설정
* 요구사항분석
* 테이블, 엔티티 설계 및 구축
* 비즈니스로직(레포지토리, 서비스) 구축 및 테스트
* 컨트롤러, 뷰 구축
* !!! 진행시 배웠던것 !!!
    - 서비스, 도메인모델
    - 도메인모델이 단순히 Entity로써 필드만 운용하는것이아니라
    - 핵심 비즈니스로직 (주문취소시 다른 엔티티에 재고량 다시 원복이랑 등등)이 들어가있으면 편하다
    - 서비스 레이어가 얇아질 수 있다

## ch12
* 스프링 데이터 JPA
## ch13
* 웹 어플리케이션과 영속성 관리
## ch14
* 컬렉션과 부가기능
## ch15
* 고급 주제와 성능 최적화

## ch16
* 트랜잭션과 락, 2차 캐시
