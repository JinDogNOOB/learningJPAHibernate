# learn hibernate
## ch01_testing > ./ch01_testing
* 기본적인 hibernate 사용
    - 엔티티매니저팩토리 생성은 비용이 많이 드니 어플리케이션 당 하나
    - 앤티티매니저를 여러 쓰레드에서 공동으로 쓰지말라
    - persistence.xml 작성!!
## ch03 > ./ch01_testing
* 영속성 관리
* em.persist(member)
* 단순히 회원 엔티티를 저장이 아니라 -> 엔티티 매니저를 사용해서 회원 엔티티를 영속성 컨텍스트에 저장
* 영속성 컨텍스트는 엔티티 매니저를 생성할때 하나 만들어지고, 엔티티매니저를 통해서 이것에 접근하거나 관리할 수 있음
* 엔티티 생명주기
    - 비영속(new/transient) : 영속성 컨텍스트와 전혀 관계가 없음
        - new -> persist() -> managed
    - 영속(managed) : 영속성 컨텍스트에 저장된 상태
        - managed -> close(), clear(), detach() -> detached
        - managed -> remove() -> removed
        - DB에 flush 명령
        - find() with JPQL -> managed 
    - 준영속(detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태
        - detached -> merge() -> managed
    - 삭제(removed) : 삭제된 상태
        - removed -> persist() -> managed

* 엔티티 생명주기 설명
    - 비영속
        - 엔티티 객체를 new Member() 식으로 생성한 상태, 순수한 객체 상태, 따라서 영속성컨텍스트나 디비와 관계없음
    - 영속
        - 엔티티 매니저를 통해서 persist() 메소드 통해 영속성 컨텍스트에 저장됐다. 이렇게 영속성 컨텍스트가 관리하는 엔티티를 영속상태라함
        - 엔티티 매니저에 의해 관리되는 상태가 되었다...
        - em.find() 또는 JPQL을 통해 조회한 엔티티도 영속성 컨텍스트에 의해 관리된다
    - 준영속
        - 영속성 컨텍스트가 관리하던 영속 상태의 엔티티를 영속성 컨텍스트가 관리하지 않으면 준영속 상태가 됨
        - em.detach() 를 통해서 준영속 상태로 만들 수 있다. 
        - em.close() 를 호출해서 영속성 컨텍스트를 닫거나 em.clear() 를 호출해서 영속성 컨텍스트를 초기화해도 관리되던 영속상태 엔티티들이 동일하게 준영속상태로 된다
    - 삭제
        - 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제한다
        - em.remove()
* 영속성 컨텍스트 특징
    - 식별자값
        - 영속성 컨텍스트는 엔티티를 식별자값(@Id로 테이블의 기본키와 매핑한 값)으로 구분함
        - 반드시 영속상태는 식별자 값이 있어야함 -> 없으면 exception
    - 영속성 컨텍스트에 있는 엔티티의 저장 시기
        - 보통 트랜잭션을 커밋하는 순간 -> 영속성컨텍스트에 저장된 엔티티를 데이터베이스에 반영
        - 위 같은 상황을 flush 라고 함(쓰기 지연 SQL 저장소 에 모인 쿼리(변경감지:스냅샷 비교 후 확인된 변경사항적용 쿼리 포함)를 db에 보내서 서로 상태 동기화)

## ch04 > ./ch01_testing
* 엔티티 매핑

## ch05 > ./ch05_basicremapping
* 연관관계 매핑 기초
    - 객체의 참조와 테이블의 외래키를 매핑
* 방향
    - 방향
        - 둘 중 한쪽만 참조하는 것을 단방향 관계라고 함
        - 회원 -> 팀 또는 팀 -> 회원
        - 서로 참조하는 경우는 양방향이라고함
    - 다중성
        - N:1, 1:N, 1:1, N:M
        - 만약에 회원과 팀이 관계가 있을때 
        - 여러 회원은 한 팀에 속하므로 회원과 팀은 다대 일 관계임
    - 연관관계의 주인
        - 객체를 양방향 연관관계로 만들면 연관관계의 주인을 정해야 한다

## ch06 > ./ch06_admapping
* 고급 매핑
* 상속관계 매핑
    - 객체의 상속 관계를 테이터베이스에 매핑하는 방법
    - 환경
        - orm(상속) < - > db(슈퍼타입 서브타입) 과 유사 이런식을 할때 사용함
    - DB 테이블 설계 방법
        - 1. 각각의 테이블로 변환 (공통 테이블, 앨범 테이블, 무비 테이블, 책 테이블) 조인전략
        - 2. 통합 테이블로 변환 (하나의 테이블에 컬럼 다 집어넣고 구분컬럼 DTYPE 삽입)
        - 3. 서브타입 테이블로 변환 (서브타입마다 하나의 테이블 생성 (앨범, 무비, 책 테이블))
    - 조인전략 > joinStrategy
        - 장점 : 테이블정규화, 저장공간 효율적
        - 단점 : 조회할 때 조인이 많이 사용되므로 성능 저하우려, 조회쿼리 복잡, 등록할때 insert sql 두번 동작
    - 단일 테이블 전략 > singleTableStrategy
        - 조인전략이랑 클래스설계는 다른게 없음
        - 어노테이션 밸류만 single_table로 바꾸면됨
        - db 컬럼에 null허용 해줘야한다
        - 장점 : 조인이 필요없으므로 조회성능 빠름, 조회쿼리 단순
        - 단점 : 자식 엔티티가 매핑한 컬럼은 모두 null허용해야함, 단일 테이블에 전부 저장하므로 테이블이 커질 수 있음, 상황에 따라서 성능저하 유발
        - 주의 : 구분컬럼 꼭 넣어야한다. 구분컬럼 설정안하면 기본적으로 엔티티 이름 사용함
    - 구현 클래스마다 테이블 전략
        - @Inheritance 의 strategy에 TABLE_PER_CLASS 설정
        - 클래스 구조는 조인전략과 다를 게 없음
        - 장점 : 서브타입 구분해서 처리할때 효과적, not null 제약조건 사용가능
        - 단점 : 여러 자식 테이블을 함께 조회할때 성능 느림(sql union), 통합해서 쿼리하기 어려움 자식들을 하나로
        - 주의 : orm전문가 db설계전문가 둘 다 추천하지 않는 방법임 지양

* @MappedSuperclass
    - 여러 엔티티에서 공통적으로 사용하는 매핑 정보(등록일, 수정일)만 상속받는 방법
    - 부모추상클래스는 실제 db에 매핑되지않는다 entity가 아니다
    - 부모추상클래스는 단순히 자식클래스에 매핑필드 정보만 준다.
    - Member와 Seller 두 엔티티에 id와 name의 공통 필드가 있으면 이것만 빼서 부모추상클래스에 넣는 방법이다. 반복해서 넣기 귀찮을때 사용하는 방법일 수도 있다. 또는 자주 바뀌는 요구사항을 맞추기위해 유지보수 쉽게하기위해
    - 부모의 매핑정보를 재정의하려면 오버라이드하면 된다.

* 복합 키와 식별 관계 매핑
    - 테이터 베이스에서 식별자가 하나 이상일때 매핑하는 방법, DB설계시 식별관계와 비식별관계에 대해 
    - 식별관계와 비식별관계
        - 식별관계 : 부모로부터 기본키를 내려받아서 이를 자식테이블 기본키 + 외래키 두개의 역할로 쓸때 부모와 자식을 식별관계라고함
        - 비식별관계 : 자식의 키가 따로있고 부모로부터 받은 키는 외래키로만 사용, 선택적 비식별관계(외래키 null 가능), 필수적 비식별관계(부모키필수로 받아야한다!)
        - 최근 선호도 : 주로 비식별관계를 쓰고 필요한 곳에만 식별관계 사용
    - 복합키:비식별 관계일때 > deidentifiedRel
        - 그냥 하나의 엔티티에 @Id 두개 넣으면 안됨 매핑오류 발생
        - JPA는 복합키를 지원하기 위해 @IdClass, @EmbeddedId 라는 두가지 방법 지원
        - @IdClass : 관계형 테이터베이스에 가까운 방법
        - @EmbeddedId : 객체지향에 가까운 방법
    - 복합키:식별 관계일때 > identifiedRel

* 조인 테이블
    - 외래키 하나로 연관관계를 맺는 것 대신에 연결 테이블을 두는 방식을 사용할때, 이 연결 테이블을 매핑하는 방법.. 별로 안쓴다고함
* 엔티티 하나에 여러 테이블 매핑
    - 보통 엔티티 하나에 하나의 테이블을 매핑하는데, 여러 테이블을 매핑하는 방법, 별로 안쓴다고함


## ch08
* 프록시 & 연관관계 관리
* 프록시와 즉시로딩, 지연로딩
    - 객체는 객체 그래프로 연관된 객체들을 탐색, 그런데 객체가 데이터베이스에 저장되어 있으므로 연관된 객체를 마음껏 탐색하기는 어려움, JPA 구현체들은 이 문제를 해결하기 위해서 프록시라는 기술을 사용함. 프록시를 사용하면 연관된 객체를 처음부터 데이터베이스에서 조회하는것이 아니라, 실제 사용하는 시점에 데이터베이스에서 조회하는 것임. 하지만 자주사용하는 것이면은 조인을 사용해서 함께 조회하는것이 좋음. JPA는 즉시로딩과 지연로딩이라는 방법으로 두가지를 모두 지원함
    - 프록시
        - Team team = em.getReference(Team.class, "team1"); team.getId(); // 초기화되지않음
        - @Access(AccessType.PROPERTY) 설정인 경우에만 초기화하지않는다.
        - @Access(AccessType.FIELD) 설정인 경우에는 프록시 객체를 초기화한다.
        - 이 프록시를 사용하면 멤버를 생성하고 멤버에 연관관계를 주입할때 유용하게쓸수있다. 데이터베이스 접근 횟수를 줄일수있다.
        - em.getEnmtityManagerFactory().getPersistenceUnitUtil().isLoaded(object) 로 프록시가 초기화 됬는지 확인 가능하다
    - 즉시로딩
        - 멤버조회할때 연관된 팀도 가져옴
        - @ManyToOne(fetch = FetchType.EAGER)
    - 지연로딩
        - 연관된 엔티티를 실제로 사용할때 가져온다
        - @ManyToOne(fetch = FetchType.LAZY)
    - JPA의 기본전략
        - ~ToMany 일때는 지연
        - ~ToOne 일때는 즉시

* 영속성 전이와 고아 객체
    - JPA는 연관된 객체를 함께 저장하거나 함께 삭제할 수 있는 '영속성 전이'와 '고아 객체 제거' 라는 편리한 기능을 제공함
    - CascadeType 옵션
        - ALL : 전부적용
        - PERSIST : 영속 child에 부모넣고 부모 persist하면 자식도 자동으로 저장
        - MERGE : 병합
        - REMOVE : 삭제 부모만 없애도 자식도 다 없어짐
        - REFRESH : refresh
        - DETACH : detach
    - CasCade 옵션은 @OneToMany 안에 설정한다 ex(cascade = CascadeType.PERSIST)
    - 고아 객체 제거 orphanRemoval = true -> 부모엔티티의 자식s 엔티티에서 컬렉션에서 제거하면 삭제된다.

## ch09
* 값 타입

## ch10 
* 객체지향쿼리언어

## ch11 
* 웹 어플리케이션 제작

## ch12
* 스프링 데이터 JPA
## ch13
* 웹 어플리케이션과 영속성 관리
## ch14
* 컬렉션과 부가기능
## ch15
* 고급 주제와 성능 최적화

## ch16
* 트랜잭션과 락, 2차 캐시
